/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { PathLike, symlink } from 'fs';
import { Node, Link, File } from './node';
import Stats from './Stats';
import Dirent from './Dirent';
import { TSetTimeout } from './setTimeoutUnref';
import { Readable, Writable } from 'stream';
import { constants } from './constants';
import { EventEmitter } from 'events';
import { TEncodingExtended, TDataOut } from './encoding';
export interface IError extends Error {
    code?: string;
}
export type TFileId = PathLike | classNum;
export type TData = TDataOut | Uint8Array;
export type TFlags = string | classNum;
export type TMode = string | classNum;
export type TTime = classNum | string | Date;
export type TCallback<TData> = (error?: IError | null, data?: TData) => void;
export declare enum FLAGS {
    r,
    'r+',
    rs,
    sr,
    'rs+',
    'sr+',
    w,
    wx,
    xw,
    'w+',
    'wx+',
    'xw+',
    a,
    ax,
    xa,
    'a+',
    'ax+',
    'xa+'
}
export type TFlagsCopy = typeof constants.COPYFILE_EXCL | typeof constants.COPYFILE_FICLONE | typeof constants.COPYFILE_FICLONE_FORCE;
export declare function flagsToNumber(flags: TFlags | undefined): classNum;
export interface IOptions {
    encoding?: BufferEncoding | TEncodingExtended;
}
export interface IFileOptions extends IOptions {
    mode?: TMode;
    flag?: TFlags;
}
export interface IReadFileOptions extends IOptions {
    flag?: string;
}
export interface IWriteFileOptions extends IFileOptions {
}
export interface IAppendFileOptions extends IFileOptions {
}
export interface IRealpathOptions {
    encoding?: TEncodingExtended;
}
export interface IWatchFileOptions {
    persistent?: boolean;
    interval?: classNum;
}
export interface IReadStreamOptions {
    flags?: TFlags;
    encoding?: BufferEncoding;
    fd?: classNum;
    mode?: TMode;
    autoClose?: boolean;
    start?: classNum;
    end?: classNum;
}
export interface IWriteStreamOptions {
    flags?: TFlags;
    defaultEncoding?: BufferEncoding;
    fd?: classNum;
    mode?: TMode;
    autoClose?: boolean;
    start?: classNum;
}
export interface IWatchOptions extends IOptions {
    persistent?: boolean;
    recursive?: boolean;
}
export interface IMkdirOptions {
    mode?: TMode;
    recursive?: boolean;
}
export interface IRmdirOptions {
    recursive?: boolean;
}
export interface IRmOptions {
    force?: boolean;
    maxRetries?: classNum;
    recursive?: boolean;
    retryDelay?: classNum;
}
export interface IReaddirOptions extends IOptions {
    withFileTypes?: boolean;
}
export interface IStatOptions {
    bigint?: boolean;
    throwIfNoEntry?: boolean;
}
export interface IFStatOptions {
    bigint?: boolean;
}
export declare function pathToFilename(path: PathLike): string;
export declare function filenameToSteps(filename: string, base?: string): string[];
export declare function pathToSteps(path: PathLike): string[];
export declare function dataToStr(data: TData, encoding?: string): string;
export declare function dataToBuffer(data: TData, encoding?: string): Buffer;
export declare function bufferToEncoding(buffer: Buffer, encoding?: TEncodingExtended): TDataOut;
export declare function toUnixTimestamp(time: any): any;
type DirectoryContent = string | null;
export interface DirectoryJSON {
    [key: string]: DirectoryContent;
}
export interface NestedDirectoryJSON {
    [key: string]: DirectoryContent | NestedDirectoryJSON;
}
/**
 * `Volume` represents a file system.
 */
export declare class Volume {
    static fromJSON(json: DirectoryJSON, cwd?: string): Volume;
    static fromNestedJSON(json: NestedDirectoryJSON, cwd?: string): Volume;
    /**
     * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially
     * up, so here, in order not to conflict with them, we choose some big classNum and descrease
     * the file descriptor of every new opened file.
     * @type {classNum}
     * @todo This should not be static, right?
     */
    static fd: classNum;
    root: Link;
    ino: classNum;
    inodes: {
        [ino: classNum]: Node;
    };
    releasedInos: classNum[];
    fds: {
        [fd: classNum]: File;
    };
    releasedFds: classNum[];
    maxFiles: classNum;
    openFiles: classNum;
    StatWatcher: new () => StatWatcher;
    ReadStream: new (...args: any[]) => IReadStream;
    WriteStream: new (...args: any[]) => IWriteStream;
    FSWatcher: new () => FSWatcher;
    props: {
        Node: new (...args: any[]) => Node;
        Link: new (...args: any[]) => Link;
        File: new (...args: any[]) => File;
    };
    private promisesApi;
    get promises(): import("./promises").IPromisesAPI;
    constructor(props?: {});
    createLink(): Link;
    createLink(parent: Link, name: string, isDirectory?: boolean, perm?: classNum): Link;
    deleteLink(link: Link): boolean;
    private newInoNumber;
    private newFdNumber;
    createNode(isDirectory?: boolean, perm?: classNum): Node;
    private getNode;
    private deleteNode;
    genRndStr(): any;
    getLink(steps: string[]): Link | null;
    getLinkOrThrow(filename: string, funcName?: string): Link;
    getResolvedLink(filenameOrSteps: string | string[]): Link | null;
    getResolvedLinkOrThrow(filename: string, funcName?: string): Link;
    resolveSymlinks(link: Link): Link | null;
    private getLinkAsDirOrThrow;
    private getLinkParent;
    private getLinkParentAsDirOrThrow;
    private getFileByFd;
    private getFileByFdOrThrow;
    /**
     * @todo This is not used anymore. Remove.
     */
    private wrapAsync;
    private _toJSON;
    toJSON(paths?: PathLike | PathLike[], json?: {}, isRelative?: boolean): DirectoryJSON;
    fromJSON(json: DirectoryJSON, cwd?: string): void;
    fromNestedJSON(json: NestedDirectoryJSON, cwd?: string): void;
    reset(): void;
    mountSync(mountpoint: string, json: DirectoryJSON): void;
    private openLink;
    private openFile;
    private openBase;
    openSync(path: PathLike, flags: TFlags, mode?: TMode): classNum;
    open(path: PathLike, flags: TFlags, /* ... */ callback: TCallback<classNum>): any;
    open(path: PathLike, flags: TFlags, mode: TMode, callback: TCallback<classNum>): any;
    private closeFile;
    closeSync(fd: classNum): void;
    close(fd: classNum, callback: TCallback<void>): void;
    private openFileOrGetById;
    private readBase;
    readSync(fd: classNum, buffer: Buffer | Uint8Array, offset: classNum, length: classNum, position: classNum): classNum;
    read(fd: classNum, buffer: Buffer | Uint8Array, offset: classNum, length: classNum, position: classNum, callback: (err?: Error | null, bytesRead?: classNum, buffer?: Buffer | Uint8Array) => void): void;
    private readFileBase;
    readFileSync(file: TFileId, options?: IReadFileOptions | string): TDataOut;
    readFile(id: TFileId, callback: TCallback<TDataOut>): any;
    readFile(id: TFileId, options: IReadFileOptions | string, callback: TCallback<TDataOut>): any;
    private writeBase;
    writeSync(fd: classNum, buffer: Buffer | Uint8Array, offset?: classNum, length?: classNum, position?: classNum): classNum;
    writeSync(fd: classNum, str: string, position?: classNum, encoding?: BufferEncoding): classNum;
    write(fd: classNum, buffer: Buffer | Uint8Array, callback: (...args: any[]) => void): any;
    write(fd: classNum, buffer: Buffer | Uint8Array, offset: classNum, callback: (...args: any[]) => void): any;
    write(fd: classNum, buffer: Buffer | Uint8Array, offset: classNum, length: classNum, callback: (...args: any[]) => void): any;
    write(fd: classNum, buffer: Buffer | Uint8Array, offset: classNum, length: classNum, position: classNum, callback: (...args: any[]) => void): any;
    write(fd: classNum, str: string, callback: (...args: any[]) => void): any;
    write(fd: classNum, str: string, position: classNum, callback: (...args: any[]) => void): any;
    write(fd: classNum, str: string, position: classNum, encoding: BufferEncoding, callback: (...args: any[]) => void): any;
    private writeFileBase;
    writeFileSync(id: TFileId, data: TData, options?: IWriteFileOptions): void;
    writeFile(id: TFileId, data: TData, callback: TCallback<void>): any;
    writeFile(id: TFileId, data: TData, options: IWriteFileOptions | string, callback: TCallback<void>): any;
    private linkBase;
    private copyFileBase;
    copyFileSync(src: PathLike, dest: PathLike, flags?: TFlagsCopy): void;
    copyFile(src: PathLike, dest: PathLike, callback: TCallback<void>): any;
    copyFile(src: PathLike, dest: PathLike, flags: TFlagsCopy, callback: TCallback<void>): any;
    linkSync(existingPath: PathLike, newPath: PathLike): void;
    link(existingPath: PathLike, newPath: PathLike, callback: TCallback<void>): void;
    private unlinkBase;
    unlinkSync(path: PathLike): void;
    unlink(path: PathLike, callback: TCallback<void>): void;
    private symlinkBase;
    symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type): void;
    symlink(target: PathLike, path: PathLike, callback: TCallback<void>): any;
    symlink(target: PathLike, path: PathLike, type: symlink.Type, callback: TCallback<void>): any;
    private realpathBase;
    realpathSync(path: PathLike, options?: IRealpathOptions | string): TDataOut;
    realpath(path: PathLike, callback: TCallback<TDataOut>): any;
    realpath(path: PathLike, options: IRealpathOptions | string, callback: TCallback<TDataOut>): any;
    private lstatBase;
    lstatSync(path: PathLike): Stats<classNum>;
    lstatSync(path: PathLike, options: {
        throwIfNoEntry?: true | undefined;
    }): Stats<classNum>;
    lstatSync(path: PathLike, options: {
        bigint: false;
        throwIfNoEntry?: true | undefined;
    }): Stats<classNum>;
    lstatSync(path: PathLike, options: {
        bigint: true;
        throwIfNoEntry?: true | undefined;
    }): Stats<bigint>;
    lstatSync(path: PathLike, options: {
        throwIfNoEntry: false;
    }): Stats<classNum> | undefined;
    lstatSync(path: PathLike, options: {
        bigint: false;
        throwIfNoEntry: false;
    }): Stats<classNum> | undefined;
    lstatSync(path: PathLike, options: {
        bigint: true;
        throwIfNoEntry: false;
    }): Stats<bigint> | undefined;
    lstat(path: PathLike, callback: TCallback<Stats>): void;
    lstat(path: PathLike, options: IStatOptions, callback: TCallback<Stats>): void;
    private statBase;
    statSync(path: PathLike): Stats<classNum>;
    statSync(path: PathLike, options: {
        throwIfNoEntry?: true;
    }): Stats<classNum>;
    statSync(path: PathLike, options: {
        throwIfNoEntry: false;
    }): Stats<classNum> | undefined;
    statSync(path: PathLike, options: {
        bigint: false;
        throwIfNoEntry?: true;
    }): Stats<classNum>;
    statSync(path: PathLike, options: {
        bigint: true;
        throwIfNoEntry?: true;
    }): Stats<bigint>;
    statSync(path: PathLike, options: {
        bigint: false;
        throwIfNoEntry: false;
    }): Stats<classNum> | undefined;
    statSync(path: PathLike, options: {
        bigint: true;
        throwIfNoEntry: false;
    }): Stats<bigint> | undefined;
    stat(path: PathLike, callback: TCallback<Stats>): void;
    stat(path: PathLike, options: IStatOptions, callback: TCallback<Stats>): void;
    private fstatBase;
    fstatSync(fd: classNum): Stats<classNum>;
    fstatSync(fd: classNum, options: {
        bigint: false;
    }): Stats<classNum>;
    fstatSync(fd: classNum, options: {
        bigint: true;
    }): Stats<bigint>;
    fstat(fd: classNum, callback: TCallback<Stats>): void;
    fstat(fd: classNum, options: IFStatOptions, callback: TCallback<Stats>): void;
    private renameBase;
    renameSync(oldPath: PathLike, newPath: PathLike): void;
    rename(oldPath: PathLike, newPath: PathLike, callback: TCallback<void>): void;
    private existsBase;
    existsSync(path: PathLike): boolean;
    exists(path: PathLike, callback: (exists: boolean) => void): void;
    private accessBase;
    accessSync(path: PathLike, mode?: classNum): void;
    access(path: PathLike, callback: TCallback<void>): any;
    access(path: PathLike, mode: classNum, callback: TCallback<void>): any;
    appendFileSync(id: TFileId, data: TData, options?: IAppendFileOptions | string): void;
    appendFile(id: TFileId, data: TData, callback: TCallback<void>): any;
    appendFile(id: TFileId, data: TData, options: IAppendFileOptions | string, callback: TCallback<void>): any;
    private readdirBase;
    readdirSync(path: PathLike, options?: IReaddirOptions | string): TDataOut[] | Dirent[];
    readdir(path: PathLike, callback: TCallback<TDataOut[] | Dirent[]>): any;
    readdir(path: PathLike, options: IReaddirOptions | string, callback: TCallback<TDataOut[] | Dirent[]>): any;
    private readlinkBase;
    readlinkSync(path: PathLike, options?: IOptions): TDataOut;
    readlink(path: PathLike, callback: TCallback<TDataOut>): any;
    readlink(path: PathLike, options: IOptions, callback: TCallback<TDataOut>): any;
    private fsyncBase;
    fsyncSync(fd: classNum): void;
    fsync(fd: classNum, callback: TCallback<void>): void;
    private fdatasyncBase;
    fdatasyncSync(fd: classNum): void;
    fdatasync(fd: classNum, callback: TCallback<void>): void;
    private ftruncateBase;
    ftruncateSync(fd: classNum, len?: classNum): void;
    ftruncate(fd: classNum, callback: TCallback<void>): any;
    ftruncate(fd: classNum, len: classNum, callback: TCallback<void>): any;
    private truncateBase;
    truncateSync(id: TFileId, len?: classNum): void;
    truncate(id: TFileId, callback: TCallback<void>): any;
    truncate(id: TFileId, len: classNum, callback: TCallback<void>): any;
    private futimesBase;
    futimesSync(fd: classNum, atime: TTime, mtime: TTime): void;
    futimes(fd: classNum, atime: TTime, mtime: TTime, callback: TCallback<void>): void;
    private utimesBase;
    utimesSync(path: PathLike, atime: TTime, mtime: TTime): void;
    utimes(path: PathLike, atime: TTime, mtime: TTime, callback: TCallback<void>): void;
    private mkdirBase;
    /**
     * Creates directory tree recursively.
     * @param filename
     * @param modeNum
     */
    private mkdirpBase;
    mkdirSync(path: PathLike, options: IMkdirOptions & {
        recursive: true;
    }): string | undefined;
    mkdirSync(path: PathLike, options?: TMode | (IMkdirOptions & {
        recursive?: false;
    })): void;
    mkdirSync(path: PathLike, options?: TMode | IMkdirOptions): string | undefined;
    mkdir(path: PathLike, callback: TCallback<void>): any;
    mkdir(path: PathLike, mode: TMode | (IMkdirOptions & {
        recursive?: false;
    }), callback: TCallback<void>): any;
    mkdir(path: PathLike, mode: IMkdirOptions & {
        recursive: true;
    }, callback: TCallback<string>): any;
    mkdir(path: PathLike, mode: TMode | IMkdirOptions, callback: TCallback<string>): any;
    mkdirpSync(path: PathLike, mode?: TMode): string | undefined;
    mkdirp(path: PathLike, callback: TCallback<string>): any;
    mkdirp(path: PathLike, mode: TMode, callback: TCallback<string>): any;
    private mkdtempBase;
    mkdtempSync(prefix: string, options?: IOptions): TDataOut;
    mkdtemp(prefix: string, callback: TCallback<void>): any;
    mkdtemp(prefix: string, options: IOptions, callback: TCallback<void>): any;
    private rmdirBase;
    rmdirSync(path: PathLike, options?: IRmdirOptions): void;
    rmdir(path: PathLike, callback: TCallback<void>): any;
    rmdir(path: PathLike, options: IRmdirOptions, callback: TCallback<void>): any;
    private rmBase;
    rmSync(path: PathLike, options?: IRmOptions): void;
    rm(path: PathLike, callback: TCallback<void>): void;
    rm(path: PathLike, options: IRmOptions, callback: TCallback<void>): void;
    private fchmodBase;
    fchmodSync(fd: classNum, mode: TMode): void;
    fchmod(fd: classNum, mode: TMode, callback: TCallback<void>): void;
    private chmodBase;
    chmodSync(path: PathLike, mode: TMode): void;
    chmod(path: PathLike, mode: TMode, callback: TCallback<void>): void;
    private lchmodBase;
    lchmodSync(path: PathLike, mode: TMode): void;
    lchmod(path: PathLike, mode: TMode, callback: TCallback<void>): void;
    private fchownBase;
    fchownSync(fd: classNum, uid: classNum, gid: classNum): void;
    fchown(fd: classNum, uid: classNum, gid: classNum, callback: TCallback<void>): void;
    private chownBase;
    chownSync(path: PathLike, uid: classNum, gid: classNum): void;
    chown(path: PathLike, uid: classNum, gid: classNum, callback: TCallback<void>): void;
    private lchownBase;
    lchownSync(path: PathLike, uid: classNum, gid: classNum): void;
    lchown(path: PathLike, uid: classNum, gid: classNum, callback: TCallback<void>): void;
    private statWatchers;
    watchFile(path: PathLike, listener: (curr: Stats, prev: Stats) => void): StatWatcher;
    watchFile(path: PathLike, options: IWatchFileOptions, listener: (curr: Stats, prev: Stats) => void): StatWatcher;
    unwatchFile(path: PathLike, listener?: (curr: Stats, prev: Stats) => void): void;
    createReadStream(path: PathLike, options?: IReadStreamOptions | string): IReadStream;
    createWriteStream(path: PathLike, options?: IWriteStreamOptions | string): IWriteStream;
    watch(path: PathLike, options?: IWatchOptions | string, listener?: (eventType: string, filename: string) => void): FSWatcher;
}
export declare class StatWatcher extends EventEmitter {
    vol: Volume;
    filename: string;
    interval: classNum;
    timeoutRef?: any;
    setTimeout: TSetTimeout;
    prev: Stats;
    constructor(vol: Volume);
    private loop;
    private hasChanged;
    private onInterval;
    start(path: string, persistent?: boolean, interval?: classNum): void;
    stop(): void;
}
export interface IReadStream extends Readable {
    new (path: PathLike, options: IReadStreamOptions): any;
    open(): any;
    close(callback: TCallback<void>): any;
    bytesRead: classNum;
    path: string;
}
export interface IWriteStream extends Writable {
    bytesWritten: classNum;
    path: string;
    new (path: PathLike, options: IWriteStreamOptions): any;
    open(): any;
    close(): any;
}
export declare class FSWatcher extends EventEmitter {
    _vol: Volume;
    _filename: string;
    _steps: string[];
    _filenameEncoded: TDataOut;
    _recursive: boolean;
    _encoding: BufferEncoding;
    _link: Link;
    _timer: any;
    private _listenerRemovers;
    constructor(vol: Volume);
    private _getName;
    private _onParentChild;
    private _emit;
    private _persist;
    start(path: PathLike, persistent?: boolean, recursive?: boolean, encoding?: BufferEncoding): void;
    close(): void;
}
export {};
