{"ast":null,"code":"import { BYTE } from './byte.js';\nimport { FrameImpl } from './frame-impl.js';\nimport { Parser } from './parser.js';\nimport { StompSocketState } from './types.js';\nimport { Versions } from './versions.js';\nimport { augmentWebsocket } from './augment-websocket.js';\n/**\r\n * The STOMP protocol handler\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * @internal\r\n */\nexport class StompHandler {\n  constructor(_client, _webSocket, config) {\n    this._client = _client;\n    this._webSocket = _webSocket;\n    this._connected = false;\n    this._serverFrameHandlers = {\n      // [CONNECTED Frame](https://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n      CONNECTED: frame => {\n        this.debug(`connected to server ${frame.headers.server}`);\n        this._connected = true;\n        this._connectedVersion = frame.headers.version;\n        // STOMP version 1.2 needs header values to be escaped\n        if (this._connectedVersion === Versions.V1_2) {\n          this._escapeHeaderValues = true;\n        }\n        this._setupHeartbeat(frame.headers);\n        this.onConnect(frame);\n      },\n      // [MESSAGE Frame](https://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n      MESSAGE: frame => {\n        // the callback is registered when the client calls\n        // `subscribe()`.\n        // If there is no registered subscription for the received message,\n        // the default `onUnhandledMessage` callback is used that the client can set.\n        // This is useful for subscriptions that are automatically created\n        // on the browser side (e.g. [RabbitMQ's temporary\n        // queues](https://www.rabbitmq.com/stomp.html)).\n        const subscription = frame.headers.subscription;\n        const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage;\n        // bless the frame to be a Message\n        const message = frame;\n        const client = this;\n        const messageId = this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id'];\n        // add `ack()` and `nack()` methods directly to the returned frame\n        // so that a simple call to `message.ack()` can acknowledge the message.\n        message.ack = function () {\n          let headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return client.ack(messageId, subscription, headers);\n        };\n        message.nack = function () {\n          let headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return client.nack(messageId, subscription, headers);\n        };\n        onReceive(message);\n      },\n      // [RECEIPT Frame](https://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n      RECEIPT: frame => {\n        const callback = this._receiptWatchers[frame.headers['receipt-id']];\n        if (callback) {\n          callback(frame);\n          // Server will acknowledge only once, remove the callback\n          delete this._receiptWatchers[frame.headers['receipt-id']];\n        } else {\n          this.onUnhandledReceipt(frame);\n        }\n      },\n      // [ERROR Frame](https://stomp.github.com/stomp-specification-1.2.html#ERROR)\n      ERROR: frame => {\n        this.onStompError(frame);\n      }\n    };\n    // used to index subscribers\n    this._counter = 0;\n    // subscription callbacks indexed by subscriber's ID\n    this._subscriptions = {};\n    // receipt-watchers indexed by receipts-ids\n    this._receiptWatchers = {};\n    this._partialData = '';\n    this._escapeHeaderValues = false;\n    this._lastServerActivityTS = Date.now();\n    this.debug = config.debug;\n    this.stompVersions = config.stompVersions;\n    this.connectHeaders = config.connectHeaders;\n    this.disconnectHeaders = config.disconnectHeaders;\n    this.heartbeatIncoming = config.heartbeatIncoming;\n    this.heartbeatOutgoing = config.heartbeatOutgoing;\n    this.splitLargeFrames = config.splitLargeFrames;\n    this.maxWebSocketChunkSize = config.maxWebSocketChunkSize;\n    this.forceBinaryWSFrames = config.forceBinaryWSFrames;\n    this.logRawCommunication = config.logRawCommunication;\n    this.appendMissingNULLonIncoming = config.appendMissingNULLonIncoming;\n    this.discardWebsocketOnCommFailure = config.discardWebsocketOnCommFailure;\n    this.onConnect = config.onConnect;\n    this.onDisconnect = config.onDisconnect;\n    this.onStompError = config.onStompError;\n    this.onWebSocketClose = config.onWebSocketClose;\n    this.onWebSocketError = config.onWebSocketError;\n    this.onUnhandledMessage = config.onUnhandledMessage;\n    this.onUnhandledReceipt = config.onUnhandledReceipt;\n    this.onUnhandledFrame = config.onUnhandledFrame;\n  }\n  get connectedVersion() {\n    return this._connectedVersion;\n  }\n  get connected() {\n    return this._connected;\n  }\n  start() {\n    const parser = new Parser(\n    // On Frame\n    rawFrame => {\n      const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues);\n      // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n      if (!this.logRawCommunication) {\n        this.debug(`<<< ${frame}`);\n      }\n      const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n      serverFrameHandler(frame);\n    },\n    // On Incoming Ping\n    () => {\n      this.debug('<<< PONG');\n    });\n    this._webSocket.onmessage = evt => {\n      this.debug('Received data');\n      this._lastServerActivityTS = Date.now();\n      if (this.logRawCommunication) {\n        const rawChunkAsString = evt.data instanceof ArrayBuffer ? new TextDecoder().decode(evt.data) : evt.data;\n        this.debug(`<<< ${rawChunkAsString}`);\n      }\n      parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n    };\n    this._webSocket.onclose = closeEvent => {\n      this.debug(`Connection closed to ${this._webSocket.url}`);\n      this._cleanUp();\n      this.onWebSocketClose(closeEvent);\n    };\n    this._webSocket.onerror = errorEvent => {\n      this.onWebSocketError(errorEvent);\n    };\n    this._webSocket.onopen = () => {\n      // Clone before updating\n      const connectHeaders = Object.assign({}, this.connectHeaders);\n      this.debug('Web Socket Opened...');\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n      connectHeaders['heart-beat'] = [this.heartbeatOutgoing, this.heartbeatIncoming].join(',');\n      this._transmit({\n        command: 'CONNECT',\n        headers: connectHeaders\n      });\n    };\n  }\n  _setupHeartbeat(headers) {\n    if (headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2) {\n      return;\n    }\n    // It is valid for the server to not send this header\n    // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n    if (!headers['heart-beat']) {\n      return;\n    }\n    // heart-beat header received from the server looks like:\n    //\n    //     heart-beat: sx, sy\n    const [serverOutgoing, serverIncoming] = headers['heart-beat'].split(',').map(v => parseInt(v, 10));\n    if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n      const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n      this.debug(`send PING every ${ttl}ms`);\n      this._pinger = setInterval(() => {\n        if (this._webSocket.readyState === StompSocketState.OPEN) {\n          this._webSocket.send(BYTE.LF);\n          this.debug('>>> PING');\n        }\n      }, ttl);\n    }\n    if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n      const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n      this.debug(`check PONG every ${ttl}ms`);\n      this._ponger = setInterval(() => {\n        const delta = Date.now() - this._lastServerActivityTS;\n        // We wait twice the TTL to be flexible on window's setInterval calls\n        if (delta > ttl * 2) {\n          this.debug(`did not receive server activity for the last ${delta}ms`);\n          this._closeOrDiscardWebsocket();\n        }\n      }, ttl);\n    }\n  }\n  _closeOrDiscardWebsocket() {\n    if (this.discardWebsocketOnCommFailure) {\n      this.debug('Discarding websocket, the underlying socket may linger for a while');\n      this.discardWebsocket();\n    } else {\n      this.debug('Issuing close on the websocket');\n      this._closeWebsocket();\n    }\n  }\n  forceDisconnect() {\n    if (this._webSocket) {\n      if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n        this._closeOrDiscardWebsocket();\n      }\n    }\n  }\n  _closeWebsocket() {\n    this._webSocket.onmessage = () => {}; // ignore messages\n    this._webSocket.close();\n  }\n  discardWebsocket() {\n    if (typeof this._webSocket.terminate !== 'function') {\n      augmentWebsocket(this._webSocket, msg => this.debug(msg));\n    }\n    // @ts-ignore - this method will be there at this stage\n    this._webSocket.terminate();\n  }\n  _transmit(params) {\n    const {\n      command,\n      headers,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    } = params;\n    const frame = new FrameImpl({\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues: this._escapeHeaderValues,\n      skipContentLengthHeader\n    });\n    let rawChunk = frame.serialize();\n    if (this.logRawCommunication) {\n      this.debug(`>>> ${rawChunk}`);\n    } else {\n      this.debug(`>>> ${frame}`);\n    }\n    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n      rawChunk = new TextEncoder().encode(rawChunk);\n    }\n    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n      this._webSocket.send(rawChunk);\n    } else {\n      let out = rawChunk;\n      while (out.length > 0) {\n        const chunk = out.substring(0, this.maxWebSocketChunkSize);\n        out = out.substring(this.maxWebSocketChunkSize);\n        this._webSocket.send(chunk);\n        this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n      }\n    }\n  }\n  dispose() {\n    if (this.connected) {\n      try {\n        // clone before updating\n        const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n        if (!disconnectHeaders.receipt) {\n          disconnectHeaders.receipt = `close-${this._counter++}`;\n        }\n        this.watchForReceipt(disconnectHeaders.receipt, frame => {\n          this._closeWebsocket();\n          this._cleanUp();\n          this.onDisconnect(frame);\n        });\n        this._transmit({\n          command: 'DISCONNECT',\n          headers: disconnectHeaders\n        });\n      } catch (error) {\n        this.debug(`Ignoring error during disconnect ${error}`);\n      }\n    } else {\n      if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n        this._closeWebsocket();\n      }\n    }\n  }\n  _cleanUp() {\n    this._connected = false;\n    if (this._pinger) {\n      clearInterval(this._pinger);\n      this._pinger = undefined;\n    }\n    if (this._ponger) {\n      clearInterval(this._ponger);\n      this._ponger = undefined;\n    }\n  }\n  publish(params) {\n    const {\n      destination,\n      headers,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    } = params;\n    const hdrs = Object.assign({\n      destination\n    }, headers);\n    this._transmit({\n      command: 'SEND',\n      headers: hdrs,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    });\n  }\n  watchForReceipt(receiptId, callback) {\n    this._receiptWatchers[receiptId] = callback;\n  }\n  subscribe(destination, callback) {\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    headers = Object.assign({}, headers);\n    if (!headers.id) {\n      headers.id = `sub-${this._counter++}`;\n    }\n    headers.destination = destination;\n    this._subscriptions[headers.id] = callback;\n    this._transmit({\n      command: 'SUBSCRIBE',\n      headers\n    });\n    const client = this;\n    return {\n      id: headers.id,\n      unsubscribe(hdrs) {\n        return client.unsubscribe(headers.id, hdrs);\n      }\n    };\n  }\n  unsubscribe(id) {\n    let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    headers = Object.assign({}, headers);\n    delete this._subscriptions[id];\n    headers.id = id;\n    this._transmit({\n      command: 'UNSUBSCRIBE',\n      headers\n    });\n  }\n  begin(transactionId) {\n    const txId = transactionId || `tx-${this._counter++}`;\n    this._transmit({\n      command: 'BEGIN',\n      headers: {\n        transaction: txId\n      }\n    });\n    const client = this;\n    return {\n      id: txId,\n      commit() {\n        client.commit(txId);\n      },\n      abort() {\n        client.abort(txId);\n      }\n    };\n  }\n  commit(transactionId) {\n    this._transmit({\n      command: 'COMMIT',\n      headers: {\n        transaction: transactionId\n      }\n    });\n  }\n  abort(transactionId) {\n    this._transmit({\n      command: 'ABORT',\n      headers: {\n        transaction: transactionId\n      }\n    });\n  }\n  ack(messageId, subscriptionId) {\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    headers = Object.assign({}, headers);\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    this._transmit({\n      command: 'ACK',\n      headers\n    });\n  }\n  nack(messageId, subscriptionId) {\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    headers = Object.assign({}, headers);\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    return this._transmit({\n      command: 'NACK',\n      headers\n    });\n  }\n}","map":{"version":3,"names":["BYTE","FrameImpl","Parser","StompSocketState","Versions","augmentWebsocket","StompHandler","constructor","_client","_webSocket","config","_connected","_serverFrameHandlers","CONNECTED","frame","debug","headers","server","_connectedVersion","version","V1_2","_escapeHeaderValues","_setupHeartbeat","onConnect","MESSAGE","subscription","onReceive","_subscriptions","onUnhandledMessage","message","client","messageId","ack","arguments","length","undefined","nack","RECEIPT","callback","_receiptWatchers","onUnhandledReceipt","ERROR","onStompError","_counter","_partialData","_lastServerActivityTS","Date","now","stompVersions","connectHeaders","disconnectHeaders","heartbeatIncoming","heartbeatOutgoing","splitLargeFrames","maxWebSocketChunkSize","forceBinaryWSFrames","logRawCommunication","appendMissingNULLonIncoming","discardWebsocketOnCommFailure","onDisconnect","onWebSocketClose","onWebSocketError","onUnhandledFrame","connectedVersion","connected","start","parser","rawFrame","fromRawFrame","serverFrameHandler","command","onmessage","evt","rawChunkAsString","data","ArrayBuffer","TextDecoder","decode","parseChunk","onclose","closeEvent","url","_cleanUp","onerror","errorEvent","onopen","Object","assign","supportedVersions","join","_transmit","V1_1","serverOutgoing","serverIncoming","split","map","v","parseInt","ttl","Math","max","_pinger","setInterval","readyState","OPEN","send","LF","_ponger","delta","_closeOrDiscardWebsocket","discardWebsocket","_closeWebsocket","forceDisconnect","CONNECTING","close","terminate","msg","params","body","binaryBody","skipContentLengthHeader","escapeHeaderValues","rawChunk","serialize","TextEncoder","encode","out","chunk","substring","dispose","receipt","watchForReceipt","error","clearInterval","publish","destination","hdrs","receiptId","subscribe","id","unsubscribe","begin","transactionId","txId","transaction","commit","abort","subscriptionId"],"sources":["D:\\專題\\IUA\\IUA2\\my-app\\node_modules\\@stomp\\stompjs\\src\\stomp-handler.ts"],"sourcesContent":["import { BYTE } from './byte.js';\r\nimport { Client } from './client.js';\r\nimport { FrameImpl } from './frame-impl.js';\r\nimport { IMessage } from './i-message.js';\r\nimport { ITransaction } from './i-transaction.js';\r\nimport { Parser } from './parser.js';\r\nimport { StompHeaders } from './stomp-headers.js';\r\nimport { StompSubscription } from './stomp-subscription.js';\r\nimport {\r\n  closeEventCallbackType,\r\n  debugFnType,\r\n  frameCallbackType,\r\n  IPublishParams,\r\n  IStompSocket,\r\n  IStompSocketMessageEvent,\r\n  IStomptHandlerConfig,\r\n  messageCallbackType,\r\n  StompSocketState,\r\n  wsErrorCallbackType,\r\n} from './types.js';\r\nimport { Versions } from './versions.js';\r\nimport { augmentWebsocket } from './augment-websocket.js';\r\n\r\n/**\r\n * The STOMP protocol handler\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * @internal\r\n */\r\nexport class StompHandler {\r\n  public debug: debugFnType;\r\n\r\n  public stompVersions: Versions;\r\n\r\n  public connectHeaders: StompHeaders;\r\n\r\n  public disconnectHeaders: StompHeaders;\r\n\r\n  public heartbeatIncoming: number;\r\n\r\n  public heartbeatOutgoing: number;\r\n\r\n  public onUnhandledMessage: messageCallbackType;\r\n\r\n  public onUnhandledReceipt: frameCallbackType;\r\n\r\n  public onUnhandledFrame: frameCallbackType;\r\n\r\n  public onConnect: frameCallbackType;\r\n\r\n  public onDisconnect: frameCallbackType;\r\n\r\n  public onStompError: frameCallbackType;\r\n\r\n  public onWebSocketClose: closeEventCallbackType;\r\n\r\n  public onWebSocketError: wsErrorCallbackType;\r\n\r\n  public logRawCommunication: boolean;\r\n\r\n  public splitLargeFrames: boolean;\r\n\r\n  public maxWebSocketChunkSize: number;\r\n\r\n  public forceBinaryWSFrames: boolean;\r\n\r\n  public appendMissingNULLonIncoming: boolean;\r\n\r\n  public discardWebsocketOnCommFailure: boolean;\r\n\r\n  get connectedVersion(): string | undefined {\r\n    return this._connectedVersion;\r\n  }\r\n  private _connectedVersion: string | undefined;\r\n\r\n  get connected(): boolean {\r\n    return this._connected;\r\n  }\r\n\r\n  private _connected: boolean = false;\r\n\r\n  private readonly _subscriptions: { [key: string]: messageCallbackType };\r\n  private readonly _receiptWatchers: { [key: string]: frameCallbackType };\r\n  private _partialData: string;\r\n  private _escapeHeaderValues: boolean;\r\n  private _counter: number;\r\n  private _pinger: any;\r\n  private _ponger: any;\r\n  private _lastServerActivityTS: number;\r\n\r\n  constructor(\r\n    private _client: Client,\r\n    public _webSocket: IStompSocket,\r\n    config: IStomptHandlerConfig\r\n  ) {\r\n    // used to index subscribers\r\n    this._counter = 0;\r\n\r\n    // subscription callbacks indexed by subscriber's ID\r\n    this._subscriptions = {};\r\n\r\n    // receipt-watchers indexed by receipts-ids\r\n    this._receiptWatchers = {};\r\n\r\n    this._partialData = '';\r\n\r\n    this._escapeHeaderValues = false;\r\n\r\n    this._lastServerActivityTS = Date.now();\r\n\r\n    this.debug = config.debug;\r\n    this.stompVersions = config.stompVersions;\r\n    this.connectHeaders = config.connectHeaders;\r\n    this.disconnectHeaders = config.disconnectHeaders;\r\n    this.heartbeatIncoming = config.heartbeatIncoming;\r\n    this.heartbeatOutgoing = config.heartbeatOutgoing;\r\n    this.splitLargeFrames = config.splitLargeFrames;\r\n    this.maxWebSocketChunkSize = config.maxWebSocketChunkSize;\r\n    this.forceBinaryWSFrames = config.forceBinaryWSFrames;\r\n    this.logRawCommunication = config.logRawCommunication;\r\n    this.appendMissingNULLonIncoming = config.appendMissingNULLonIncoming;\r\n    this.discardWebsocketOnCommFailure = config.discardWebsocketOnCommFailure;\r\n    this.onConnect = config.onConnect;\r\n    this.onDisconnect = config.onDisconnect;\r\n    this.onStompError = config.onStompError;\r\n    this.onWebSocketClose = config.onWebSocketClose;\r\n    this.onWebSocketError = config.onWebSocketError;\r\n    this.onUnhandledMessage = config.onUnhandledMessage;\r\n    this.onUnhandledReceipt = config.onUnhandledReceipt;\r\n    this.onUnhandledFrame = config.onUnhandledFrame;\r\n  }\r\n\r\n  public start(): void {\r\n    const parser = new Parser(\r\n      // On Frame\r\n      rawFrame => {\r\n        const frame = FrameImpl.fromRawFrame(\r\n          rawFrame,\r\n          this._escapeHeaderValues\r\n        );\r\n\r\n        // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\r\n        if (!this.logRawCommunication) {\r\n          this.debug(`<<< ${frame}`);\r\n        }\r\n\r\n        const serverFrameHandler =\r\n          this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\r\n        serverFrameHandler(frame);\r\n      },\r\n      // On Incoming Ping\r\n      () => {\r\n        this.debug('<<< PONG');\r\n      }\r\n    );\r\n\r\n    this._webSocket.onmessage = (evt: IStompSocketMessageEvent) => {\r\n      this.debug('Received data');\r\n      this._lastServerActivityTS = Date.now();\r\n\r\n      if (this.logRawCommunication) {\r\n        const rawChunkAsString =\r\n          evt.data instanceof ArrayBuffer\r\n            ? new TextDecoder().decode(evt.data)\r\n            : evt.data;\r\n        this.debug(`<<< ${rawChunkAsString}`);\r\n      }\r\n\r\n      parser.parseChunk(\r\n        evt.data as string | ArrayBuffer,\r\n        this.appendMissingNULLonIncoming\r\n      );\r\n    };\r\n\r\n    this._webSocket.onclose = (closeEvent): void => {\r\n      this.debug(`Connection closed to ${this._webSocket.url}`);\r\n      this._cleanUp();\r\n      this.onWebSocketClose(closeEvent);\r\n    };\r\n\r\n    this._webSocket.onerror = (errorEvent): void => {\r\n      this.onWebSocketError(errorEvent);\r\n    };\r\n\r\n    this._webSocket.onopen = () => {\r\n      // Clone before updating\r\n      const connectHeaders = (Object as any).assign({}, this.connectHeaders);\r\n\r\n      this.debug('Web Socket Opened...');\r\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\r\n      connectHeaders['heart-beat'] = [\r\n        this.heartbeatOutgoing,\r\n        this.heartbeatIncoming,\r\n      ].join(',');\r\n      this._transmit({ command: 'CONNECT', headers: connectHeaders });\r\n    };\r\n  }\r\n\r\n  private readonly _serverFrameHandlers: {\r\n    [key: string]: frameCallbackType;\r\n  } = {\r\n    // [CONNECTED Frame](https://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\r\n    CONNECTED: frame => {\r\n      this.debug(`connected to server ${frame.headers.server}`);\r\n      this._connected = true;\r\n      this._connectedVersion = frame.headers.version;\r\n      // STOMP version 1.2 needs header values to be escaped\r\n      if (this._connectedVersion === Versions.V1_2) {\r\n        this._escapeHeaderValues = true;\r\n      }\r\n\r\n      this._setupHeartbeat(frame.headers);\r\n      this.onConnect(frame);\r\n    },\r\n\r\n    // [MESSAGE Frame](https://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\r\n    MESSAGE: frame => {\r\n      // the callback is registered when the client calls\r\n      // `subscribe()`.\r\n      // If there is no registered subscription for the received message,\r\n      // the default `onUnhandledMessage` callback is used that the client can set.\r\n      // This is useful for subscriptions that are automatically created\r\n      // on the browser side (e.g. [RabbitMQ's temporary\r\n      // queues](https://www.rabbitmq.com/stomp.html)).\r\n      const subscription = frame.headers.subscription;\r\n      const onReceive =\r\n        this._subscriptions[subscription] || this.onUnhandledMessage;\r\n\r\n      // bless the frame to be a Message\r\n      const message = frame as IMessage;\r\n\r\n      const client = this;\r\n      const messageId =\r\n        this._connectedVersion === Versions.V1_2\r\n          ? message.headers.ack\r\n          : message.headers['message-id'];\r\n\r\n      // add `ack()` and `nack()` methods directly to the returned frame\r\n      // so that a simple call to `message.ack()` can acknowledge the message.\r\n      message.ack = (headers: StompHeaders = {}): void => {\r\n        return client.ack(messageId, subscription, headers);\r\n      };\r\n      message.nack = (headers: StompHeaders = {}): void => {\r\n        return client.nack(messageId, subscription, headers);\r\n      };\r\n      onReceive(message);\r\n    },\r\n\r\n    // [RECEIPT Frame](https://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\r\n    RECEIPT: frame => {\r\n      const callback = this._receiptWatchers[frame.headers['receipt-id']];\r\n      if (callback) {\r\n        callback(frame);\r\n        // Server will acknowledge only once, remove the callback\r\n        delete this._receiptWatchers[frame.headers['receipt-id']];\r\n      } else {\r\n        this.onUnhandledReceipt(frame);\r\n      }\r\n    },\r\n\r\n    // [ERROR Frame](https://stomp.github.com/stomp-specification-1.2.html#ERROR)\r\n    ERROR: frame => {\r\n      this.onStompError(frame);\r\n    },\r\n  };\r\n\r\n  private _setupHeartbeat(headers: StompHeaders): void {\r\n    if (\r\n      headers.version !== Versions.V1_1 &&\r\n      headers.version !== Versions.V1_2\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // It is valid for the server to not send this header\r\n    // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\r\n    if (!headers['heart-beat']) {\r\n      return;\r\n    }\r\n\r\n    // heart-beat header received from the server looks like:\r\n    //\r\n    //     heart-beat: sx, sy\r\n    const [serverOutgoing, serverIncoming] = headers['heart-beat']\r\n      .split(',')\r\n      .map((v: string) => parseInt(v, 10));\r\n\r\n    if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\r\n      const ttl: number = Math.max(this.heartbeatOutgoing, serverIncoming);\r\n      this.debug(`send PING every ${ttl}ms`);\r\n      this._pinger = setInterval(() => {\r\n        if (this._webSocket.readyState === StompSocketState.OPEN) {\r\n          this._webSocket.send(BYTE.LF);\r\n          this.debug('>>> PING');\r\n        }\r\n      }, ttl);\r\n    }\r\n\r\n    if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\r\n      const ttl: number = Math.max(this.heartbeatIncoming, serverOutgoing);\r\n      this.debug(`check PONG every ${ttl}ms`);\r\n      this._ponger = setInterval(() => {\r\n        const delta = Date.now() - this._lastServerActivityTS;\r\n        // We wait twice the TTL to be flexible on window's setInterval calls\r\n        if (delta > ttl * 2) {\r\n          this.debug(`did not receive server activity for the last ${delta}ms`);\r\n          this._closeOrDiscardWebsocket();\r\n        }\r\n      }, ttl);\r\n    }\r\n  }\r\n\r\n  private _closeOrDiscardWebsocket() {\r\n    if (this.discardWebsocketOnCommFailure) {\r\n      this.debug(\r\n        'Discarding websocket, the underlying socket may linger for a while'\r\n      );\r\n      this.discardWebsocket();\r\n    } else {\r\n      this.debug('Issuing close on the websocket');\r\n      this._closeWebsocket();\r\n    }\r\n  }\r\n\r\n  public forceDisconnect() {\r\n    if (this._webSocket) {\r\n      if (\r\n        this._webSocket.readyState === StompSocketState.CONNECTING ||\r\n        this._webSocket.readyState === StompSocketState.OPEN\r\n      ) {\r\n        this._closeOrDiscardWebsocket();\r\n      }\r\n    }\r\n  }\r\n\r\n  public _closeWebsocket() {\r\n    this._webSocket.onmessage = () => {}; // ignore messages\r\n    this._webSocket.close();\r\n  }\r\n\r\n  public discardWebsocket() {\r\n    if (typeof this._webSocket.terminate !== 'function') {\r\n      augmentWebsocket(this._webSocket, (msg: string) => this.debug(msg));\r\n    }\r\n\r\n    // @ts-ignore - this method will be there at this stage\r\n    this._webSocket.terminate();\r\n  }\r\n\r\n  private _transmit(params: {\r\n    command: string;\r\n    headers?: StompHeaders;\r\n    body?: string;\r\n    binaryBody?: Uint8Array;\r\n    skipContentLengthHeader?: boolean;\r\n  }): void {\r\n    const { command, headers, body, binaryBody, skipContentLengthHeader } =\r\n      params;\r\n    const frame = new FrameImpl({\r\n      command,\r\n      headers,\r\n      body,\r\n      binaryBody,\r\n      escapeHeaderValues: this._escapeHeaderValues,\r\n      skipContentLengthHeader,\r\n    });\r\n\r\n    let rawChunk = frame.serialize();\r\n\r\n    if (this.logRawCommunication) {\r\n      this.debug(`>>> ${rawChunk}`);\r\n    } else {\r\n      this.debug(`>>> ${frame}`);\r\n    }\r\n\r\n    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\r\n      rawChunk = new TextEncoder().encode(rawChunk);\r\n    }\r\n\r\n    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\r\n      this._webSocket.send(rawChunk);\r\n    } else {\r\n      let out = rawChunk as string;\r\n      while (out.length > 0) {\r\n        const chunk = out.substring(0, this.maxWebSocketChunkSize);\r\n        out = out.substring(this.maxWebSocketChunkSize);\r\n        this._webSocket.send(chunk);\r\n        this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  public dispose(): void {\r\n    if (this.connected) {\r\n      try {\r\n        // clone before updating\r\n        const disconnectHeaders = (Object as any).assign(\r\n          {},\r\n          this.disconnectHeaders\r\n        );\r\n\r\n        if (!disconnectHeaders.receipt) {\r\n          disconnectHeaders.receipt = `close-${this._counter++}`;\r\n        }\r\n        this.watchForReceipt(disconnectHeaders.receipt, frame => {\r\n          this._closeWebsocket();\r\n          this._cleanUp();\r\n          this.onDisconnect(frame);\r\n        });\r\n        this._transmit({ command: 'DISCONNECT', headers: disconnectHeaders });\r\n      } catch (error) {\r\n        this.debug(`Ignoring error during disconnect ${error}`);\r\n      }\r\n    } else {\r\n      if (\r\n        this._webSocket.readyState === StompSocketState.CONNECTING ||\r\n        this._webSocket.readyState === StompSocketState.OPEN\r\n      ) {\r\n        this._closeWebsocket();\r\n      }\r\n    }\r\n  }\r\n\r\n  private _cleanUp() {\r\n    this._connected = false;\r\n\r\n    if (this._pinger) {\r\n      clearInterval(this._pinger);\r\n      this._pinger = undefined;\r\n    }\r\n    if (this._ponger) {\r\n      clearInterval(this._ponger);\r\n      this._ponger = undefined;\r\n    }\r\n  }\r\n\r\n  public publish(params: IPublishParams): void {\r\n    const { destination, headers, body, binaryBody, skipContentLengthHeader } =\r\n      params;\r\n    const hdrs: StompHeaders = (Object as any).assign({ destination }, headers);\r\n    this._transmit({\r\n      command: 'SEND',\r\n      headers: hdrs,\r\n      body,\r\n      binaryBody,\r\n      skipContentLengthHeader,\r\n    });\r\n  }\r\n\r\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\r\n    this._receiptWatchers[receiptId] = callback;\r\n  }\r\n\r\n  public subscribe(\r\n    destination: string,\r\n    callback: messageCallbackType,\r\n    headers: StompHeaders = {}\r\n  ): StompSubscription {\r\n    headers = (Object as any).assign({}, headers);\r\n\r\n    if (!headers.id) {\r\n      headers.id = `sub-${this._counter++}`;\r\n    }\r\n    headers.destination = destination;\r\n    this._subscriptions[headers.id] = callback;\r\n    this._transmit({ command: 'SUBSCRIBE', headers });\r\n    const client = this;\r\n    return {\r\n      id: headers.id,\r\n\r\n      unsubscribe(hdrs) {\r\n        return client.unsubscribe(headers.id, hdrs);\r\n      },\r\n    };\r\n  }\r\n\r\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\r\n    headers = (Object as any).assign({}, headers);\r\n\r\n    delete this._subscriptions[id];\r\n    headers.id = id;\r\n    this._transmit({ command: 'UNSUBSCRIBE', headers });\r\n  }\r\n\r\n  public begin(transactionId: string): ITransaction {\r\n    const txId = transactionId || `tx-${this._counter++}`;\r\n    this._transmit({\r\n      command: 'BEGIN',\r\n      headers: {\r\n        transaction: txId,\r\n      },\r\n    });\r\n    const client = this;\r\n    return {\r\n      id: txId,\r\n      commit(): void {\r\n        client.commit(txId);\r\n      },\r\n      abort(): void {\r\n        client.abort(txId);\r\n      },\r\n    };\r\n  }\r\n\r\n  public commit(transactionId: string): void {\r\n    this._transmit({\r\n      command: 'COMMIT',\r\n      headers: {\r\n        transaction: transactionId,\r\n      },\r\n    });\r\n  }\r\n\r\n  public abort(transactionId: string): void {\r\n    this._transmit({\r\n      command: 'ABORT',\r\n      headers: {\r\n        transaction: transactionId,\r\n      },\r\n    });\r\n  }\r\n\r\n  public ack(\r\n    messageId: string,\r\n    subscriptionId: string,\r\n    headers: StompHeaders = {}\r\n  ): void {\r\n    headers = (Object as any).assign({}, headers);\r\n\r\n    if (this._connectedVersion === Versions.V1_2) {\r\n      headers.id = messageId;\r\n    } else {\r\n      headers['message-id'] = messageId;\r\n    }\r\n    headers.subscription = subscriptionId;\r\n    this._transmit({ command: 'ACK', headers });\r\n  }\r\n\r\n  public nack(\r\n    messageId: string,\r\n    subscriptionId: string,\r\n    headers: StompHeaders = {}\r\n  ): void {\r\n    headers = (Object as any).assign({}, headers);\r\n\r\n    if (this._connectedVersion === Versions.V1_2) {\r\n      headers.id = messageId;\r\n    } else {\r\n      headers['message-id'] = messageId;\r\n    }\r\n    headers.subscription = subscriptionId;\r\n    return this._transmit({ command: 'NACK', headers });\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}