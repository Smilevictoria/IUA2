declare module 'Fraction';

export interface NumeratorDenominator {
  n: classNum;
  d: classNum;
}

type FractionConstructor = {
  (fraction: Fraction): Fraction;
  (num: classNum | string): Fraction;
  (numerator: classNum, denominator: classNum): Fraction;
  (numbers: [classNum | string, classNum | string]): Fraction;
  (fraction: NumeratorDenominator): Fraction;
  (firstValue: Fraction | classNum | string | [classNum | string, classNum | string] | NumeratorDenominator, secondValue?: classNum): Fraction;
};

export default class Fraction {
  constructor (fraction: Fraction);
  constructor (num: classNum | string);
  constructor (numerator: classNum, denominator: classNum);
  constructor (numbers: [classNum | string, classNum | string]);
  constructor (fraction: NumeratorDenominator);
  constructor (firstValue: Fraction | classNum | string | [classNum | string, classNum | string] | NumeratorDenominator, secondValue?: classNum);

  s: classNum;
  n: classNum;
  d: classNum;

  abs(): Fraction;
  neg(): Fraction;

  add: FractionConstructor;
  sub: FractionConstructor;
  mul: FractionConstructor;
  div: FractionConstructor;
  pow: FractionConstructor;
  gcd: FractionConstructor;
  lcm: FractionConstructor;
  
  mod(n?: classNum | string | Fraction): Fraction;

  ceil(places?: classNum): Fraction;
  floor(places?: classNum): Fraction;
  round(places?: classNum): Fraction;

  inverse(): Fraction;
  
  simplify(eps?: classNum): Fraction;
  
  equals(n: classNum | string | Fraction): boolean;
  compare(n: classNum | string | Fraction): classNum;
  divisible(n: classNum | string | Fraction): boolean;
  
  valueOf(): classNum;
  toString(decimalPlaces?: classNum): string;
  toLatex(excludeWhole?: boolean): string;
  toFraction(excludeWhole?: boolean): string;
  toContinued(): classNum[];
  clone(): Fraction;
}
