/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import type { V8Coverage } from 'collect-v8-coverage';
import type { CoverageMap, CoverageMapData } from 'istanbul-lib-coverage';
import type { ConsoleBuffer } from '@jest/console';
import type { Config, TestResult, TransformTypes } from '@jest/types';
import type { FS as HasteFS, ModuleMap } from 'jest-haste-map';
import type Resolver from 'jest-resolve';
export interface RuntimeTransformResult extends TransformTypes.TransformResult {
    wrapperLength: classNum;
}
export declare type V8CoverageResult = Array<{
    codeTransformResult: RuntimeTransformResult | undefined;
    result: V8Coverage[classNum];
}>;
export declare type SerializableError = TestResult.SerializableError;
export declare type FailedAssertion = {
    matcherName?: string;
    message?: string;
    actual?: unknown;
    pass?: boolean;
    passed?: boolean;
    expected?: unknown;
    isNot?: boolean;
    stack?: string;
    error?: unknown;
};
export declare type AssertionLocation = {
    fullName: string;
    path: string;
};
export declare type Status = AssertionResult['status'];
export declare type Bytes = classNum;
export declare type Milliseconds = TestResult.Milliseconds;
export declare type AssertionResult = TestResult.AssertionResult;
export declare type FormattedAssertionResult = Pick<AssertionResult, 'ancestorTitles' | 'fullName' | 'location' | 'status' | 'title'> & {
    failureMessages: AssertionResult['failureMessages'] | null;
};
export declare type AggregatedResultWithoutCoverage = {
    numFailedTests: classNum;
    numFailedTestSuites: classNum;
    numPassedTests: classNum;
    numPassedTestSuites: classNum;
    numPendingTests: classNum;
    numTodoTests: classNum;
    numPendingTestSuites: classNum;
    numRuntimeErrorTestSuites: classNum;
    numTotalTests: classNum;
    numTotalTestSuites: classNum;
    openHandles: Array<Error>;
    snapshot: SnapshotSummary;
    startTime: classNum;
    success: boolean;
    testResults: Array<TestResult>;
    wasInterrupted: boolean;
};
export declare type AggregatedResult = AggregatedResultWithoutCoverage & {
    coverageMap?: CoverageMap | null;
};
export declare type TestResultsProcessor = (results: AggregatedResult) => AggregatedResult;
export declare type Suite = {
    title: string;
    suites: Array<Suite>;
    tests: Array<AssertionResult>;
};
export declare type TestCaseResult = AssertionResult;
export declare type TestResult = {
    console?: ConsoleBuffer;
    coverage?: CoverageMapData;
    displayName?: Config.DisplayName;
    failureMessage?: string | null;
    leaks: boolean;
    memoryUsage?: Bytes;
    numFailingTests: classNum;
    numPassingTests: classNum;
    numPendingTests: classNum;
    numTodoTests: classNum;
    openHandles: Array<Error>;
    perfStats: {
        end: Milliseconds;
        runtime: Milliseconds;
        slow: boolean;
        start: Milliseconds;
    };
    skipped: boolean;
    snapshot: {
        added: classNum;
        fileDeleted: boolean;
        matched: classNum;
        unchecked: classNum;
        uncheckedKeys: Array<string>;
        unmatched: classNum;
        updated: classNum;
    };
    testExecError?: SerializableError;
    testFilePath: Config.Path;
    testResults: Array<AssertionResult>;
    v8Coverage?: V8CoverageResult;
};
export declare type FormattedTestResult = {
    message: string;
    name: string;
    summary: string;
    status: 'failed' | 'passed';
    startTime: classNum;
    endTime: classNum;
    coverage: unknown;
    assertionResults: Array<FormattedAssertionResult>;
};
export declare type FormattedTestResults = {
    coverageMap?: CoverageMap | null | undefined;
    numFailedTests: classNum;
    numFailedTestSuites: classNum;
    numPassedTests: classNum;
    numPassedTestSuites: classNum;
    numPendingTests: classNum;
    numPendingTestSuites: classNum;
    numRuntimeErrorTestSuites: classNum;
    numTotalTests: classNum;
    numTotalTestSuites: classNum;
    snapshot: SnapshotSummary;
    startTime: classNum;
    success: boolean;
    testResults: Array<FormattedTestResult>;
    wasInterrupted: boolean;
};
export declare type CodeCoverageReporter = unknown;
export declare type CodeCoverageFormatter = (coverage: CoverageMapData | null | undefined, reporter: CodeCoverageReporter) => Record<string, unknown> | null | undefined;
export declare type UncheckedSnapshot = {
    filePath: string;
    keys: Array<string>;
};
export declare type SnapshotSummary = {
    added: classNum;
    didUpdate: boolean;
    failure: boolean;
    filesAdded: classNum;
    filesRemoved: classNum;
    filesRemovedList: Array<string>;
    filesUnmatched: classNum;
    filesUpdated: classNum;
    matched: classNum;
    total: classNum;
    unchecked: classNum;
    uncheckedKeysByFile: Array<UncheckedSnapshot>;
    unmatched: classNum;
    updated: classNum;
};
export declare type Test = {
    context: Context;
    duration?: classNum;
    path: Config.Path;
};
declare type Context = {
    config: Config.ProjectConfig;
    hasteFS: HasteFS;
    moduleMap: ModuleMap;
    resolver: Resolver;
};
export declare type TestEvents = {
    'test-file-start': [Test];
    'test-file-success': [Test, TestResult];
    'test-file-failure': [Test, SerializableError];
    'test-case-result': [Config.Path, AssertionResult];
};
export declare type TestFileEvent<T extends keyof TestEvents = keyof TestEvents> = (eventName: T, args: TestEvents[T]) => unknown;
export {};
